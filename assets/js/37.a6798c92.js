(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{396:function(t,a,v){"use strict";v.r(a);var e=v(44),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"vue虚拟dom和diff算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue虚拟dom和diff算法"}},[t._v("#")]),t._v(" vue虚拟dom和diff算法")]),t._v(" "),v("h2",{attrs:{id:"snabbdom库"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#snabbdom库"}},[t._v("#")]),t._v(" snabbdom库")]),t._v(" "),v("h2",{attrs:{id:"h函数创建vnode"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#h函数创建vnode"}},[t._v("#")]),t._v(" h函数创建vnode")]),t._v(" "),v("h2",{attrs:{id:"vnode的6个属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vnode的6个属性"}},[t._v("#")]),t._v(" vnode的6个属性")]),t._v(" "),v("p",[t._v("sel children data text key")]),t._v(" "),v("h2",{attrs:{id:"创建patch函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#创建patch函数"}},[t._v("#")]),t._v(" 创建patch函数")]),t._v(" "),v("h2",{attrs:{id:"patch函数使vnode上树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#patch函数使vnode上树"}},[t._v("#")]),t._v(" patch函数使vnode上树")]),t._v(" "),v("h2",{attrs:{id:"vnode嵌套"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vnode嵌套"}},[t._v("#")]),t._v(" vnode嵌套")]),t._v(" "),v("h2",{attrs:{id:"diff算法的三个特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#diff算法的三个特点"}},[t._v("#")]),t._v(" diff算法的三个特点")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("根据key判断是否为同一节点")])]),t._v(" "),v("li",[v("p",[t._v("只diff选择器和key相同的vnode")])]),t._v(" "),v("li",[v("p",[t._v("只进行同层比较")])])]),t._v(" "),v("h2",{attrs:{id:"patch函数内流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#patch函数内流程"}},[t._v("#")]),t._v(" patch函数内流程")]),t._v(" "),v("p",[t._v("1.第一步：判断旧节点是否为一个vnode，不是则创建一个vnode")]),t._v(" "),v("p",[t._v("2.第二步：判断新旧节点是否为同一节点，不是则用新节点替换节点")]),t._v(" "),v("p",[t._v("3.第三步：如果是同一节点，则进行精细化比较")]),t._v(" "),v("h2",{attrs:{id:"判断新旧节点是否为同一节点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#判断新旧节点是否为同一节点"}},[t._v("#")]),t._v(" 判断新旧节点是否为同一节点")]),t._v(" "),v("p",[t._v("key相同且sel相同时，如果用的text且变化了则更新旧节点的innerText值，如果不是则对他们的children进行diff算法即updateChildren方法")]),t._v(" "),v("p",[t._v("如果不为同一节点，则创建新节点并插入到旧节点之前，然后将节点移除")]),t._v(" "),v("h2",{attrs:{id:"diff算法思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#diff算法思想"}},[t._v("#")]),t._v(" diff算法思想")]),t._v(" "),v("p",[t._v("设置四个指针：新前、旧前、新后、旧后，按照以下方式去匹配是否为同一虚拟节点，若满足条件，则新前和旧前+1，新后与旧后--")]),t._v(" "),v("p",[t._v("循环体中要跳过oldCh与newCh中为空的项，具体做法就是验证新前、旧前、新后与旧后是否存在，不存在则上移或下移，然后再else if下面判断")]),t._v(" "),v("p",[t._v("1.新前与旧前相等，新前与旧前下移")]),t._v(" "),v("p",[t._v("2.新后与旧后相等，新后与旧后上移")]),t._v(" "),v("p",[t._v("3.新后与旧前（命中时，将旧前的节点移动到旧后之后），新后上移，旧前下移")]),t._v(" "),v("p",[t._v("4.新前与旧后（命中时，将旧后的节点移动到旧前之前），新前下移，旧后上移")]),t._v(" "),v("p",[t._v("5.若都没有命中，则在旧节点中寻找与新前相同的节点")]),t._v(" "),v("p",[t._v("如果能找到，则将新前patchVnode给找到的节点并将其移动到旧前之前，再在旧节点中将匹配的这项设置为undefined")]),t._v(" "),v("p",[t._v("如果没找到，则将新前插入到旧前之前")]),t._v(" "),v("p",[t._v("最后将新前下移")]),t._v(" "),v("p",[t._v("6.结束循环之后，若newCh中有剩余，则将创建剩余的新节点并插入到旧前之前；若oldCh中有剩余，则将剩余的节点移除")])])}),[],!1,null,null,null);a.default=s.exports}}]);